### lab1报告
#### task1
##### 任务3
![3](../../../../build/linux/x86_64/release/1_3.png)
直接取一个随机数扰动。

##### 任务4
![4](../../../../build/linux/x86_64/release/1_4.png)
加载蓝噪声到图片然后二值化。

##### 任务5
![5](../../../../build/linux/x86_64/release/1_5.png)
按照讲义顺序来dithering图像，使得图像看起来更自然

##### 任务6
![6](../../../../build/linux/x86_64/release/1_6.png)
利用error diffusion，按顺序每次取出已经接受前面error传递的点的值把error传递给还未更新的其临近的点，然后二值化。

#### task2
##### 任务1
![3](../../../../build/linux/x86_64/release/2_2.png)
每个像素点的值都为临近9个点的值的平均值。

##### 任务2
![3](../../../../build/linux/x86_64/release/2_3.png)
利用sobel算子来提取梯度，然后直接输出！。

#### task3
##### 任务1
![3](../../../../build/linux/x86_64/release/3_1.png)
找到对应点，然后解线性方程组来使得颜色衔接更加自然。

#### task4
##### 任务1
![3](../../../../build/linux/x86_64/release/4_1.png)
![3](../../../../build/linux/x86_64/release/4_2.png)
直接把靠左的那个点设为p0，这样只有四种情况讨论，分别是

1. $k>1$
2. $0\leq k\leq 1$
3. $-1\leq k< 0$
4. $k\leq -1$
   
直接利用Bresenham 算法绘制直线即可。

#### task5
##### 任务1
![3](../../../../build/linux/x86_64/release/5_1.png)
按照 $y$ 从大到小排序，对于 $y$ 在 $p_0\sim p_1$的点，算出对应的在 $p_0p_1$ 和 $p_0p_2$ 作为左右点的坐标，直接横着画即可。
 
对于 $y<p_1$ 的部分，算出对应的在 $p_1p_2$ 和 $p_0p_2$ 作为左右点的坐标，直接横着画即可。

#### task6
##### 任务1
![3](../../../../build/linux/x86_64/release/6_1.png)

直接按照每个缩小后的像素点对应原来哪些点，然后从中随机选 $rate\times rate$ 个点，然后取平均即可。

#### task7
##### 任务1
![3](../../../../build/linux/x86_64/release/7_1.png)

递归方法求贝塞尔曲线！